<!DOCTYPE html>
<html>
<head>
	<title>test</title>
	<meta charset="UTF-8">
	<script src="./vue.js"></script>
	<script src="./diff_match_patch.js"></script>
	<style type="text/css">
		.bbox {
			border:1px solid #ccc;
			width:45%;
			height:400px;
			overflow: auto;
			display: inline-table;
			padding: 5px;
			float: left;
		}
		.opt_lable {
			font-size: 0.9em;
			display: inline-table;
			margin:2px;
			width: 1.2em;
			text-align: center;
		}
		.txt_line {
			margin:2px 3px;
			padding: 2px 3px;
			cursor:pointer;
			display: inline-table;
			height: 24px;
		}
		.opt_add_bg {
			color: #CCCCCC;
			border: 1px dashed #CCCC99;
			background-color: #CCFFFF;
			height: 22px;
		}
		.opt_rm_bg {
			color: #333333;
			background-color: #FF9999;
			border: 1px solid #FF6666;
			height: 22px;
		}
		.opt_rm_r_bg {
			color: #999999;
			border: 1px dashed #FF6666;
			background-color: #FF9999;
			height: 22px;
		}
		.opt_button {
			color: #EEEEEE;
			background-color: #3366CC;
			width: 17px;
			height: 18px;
			padding: 1px 2px;
			font-size: 0.6em;
			border-radius: 4px/4px;
			cursor: pointer;
		}
	</style>
</head>
<body>
<div id="app">
	<div>
		<h4>MPI比对工具</h4>
	</div>
	<div>
		<b>Path:</b>
		<span v-for="node in mp_index" v-on:click="selectPath(node)" style="cursor: pointer;">
			<span>/</span>
			{{node.name}}
		</span>
	</div>
	<div class="bbox">
		<div v-for="item in left_ctrl_data">
			<em class="opt_lable" v-if="item.opt == 1">+</em>
			<em class="opt_lable" v-if="item.opt == -1">*</em>
			<em class="opt_lable" v-if="item.opt == 0"> </em>
			<div v-on:click="selectData(item)"
				v-bind:class="{opt_add_bg:item.opt==1, opt_rm_bg:item.opt==-1}"
				class="txt_line">{{item.name}}</div>
		</div>
	</div>
	<div class="bbox">
		<div v-for="item in right_ctrl_data">
			<em class="opt_lable opt_button" v-if="item.opt==1" v-on:click="moveLeft(item)">&lt;&lt;</em>
			<em class="opt_lable" v-else> </em>
			<div v-on:click="selectData(item)"
				v-bind:class="{opt_rm_r_bg:item.opt==-1}"
				class="txt_line">
				{{item.name}}
			</div>
		</div>
	</div>
	<div>

	</div>
</div>
	<script type="text/javascript">
		var prod_mp_data
		var sc_mp_data
		fetch('./prod_mp_data.json')
		.then(response => response.json())
		.then(data => {
			prod_mp_data = data.data
			console.log("prod_mp_data", prod_mp_data)
		})
		fetch('./sc_mp_data.json')
		.then(response => response.json())
		.then(data => {
			sc_mp_data = data.data
			console.log("sc_mp_data", sc_mp_data)
		})

		function diff_lineMode(text1, text2) {
			var dmp = new diff_match_patch()
			var a = dmp.diff_linesToChars_(text1, text2)
			var lineText1 = a.chars1
			var lineText2 = a.chars2
			var lineArray = a.lineArray
			var diffs = dmp.diff_main(lineText1, lineText2, false)
			dmp.diff_charsToLines_(diffs, lineArray)
		
			return diffs;
		}

		var mp_test_data = [{'manageProductImplCode':'MPI20210625120222062564'}]

		var mp_key_frame = {'MPI':"MP", "bizProducts":"产品类型列表", "bizProductFlows":"工作流列表","flowRuleAggr":"工作流规则集"}
		var origin_data = ['Ability', 'ApplicationInit', 'Product', 'MP', 'MPI']
		var mpi_topology = {
			'code':'MPI',
			'name':'MP实例',
			'type': Object,
			'depth':1,
			'leaf':false,
			'fields':['bizProducts'],
			'children': [{
			// 	'code':'creatorCode',
			// 	'name':'创建者',
			// 	'type': String,
			// 	'depth':2,
			// 	'leaf':true,
			// },
			// {
			// 	'code':'affectedInfo',
			// 	'name':'创建者',
			// 	'type': Array,
			// 	'depth':2,
			// 	'leaf':true,
			// },
			// {
				'code':'bizProducts',
				'name':'产品类型列表',
				'type': Array,
				'depth':2,
				'leaf':false,
				'fields':[],
				'showKey':{'key':'bizProductCode','name':'bizProductName'},
				'children' : [{
					'code':'-',
					'name':'工作流列表',
					'type': Object,
					'depth':3,
					'leaf':false,
					'fields':['bizProductFlows'],
					// 'showKey':{'key':'bizProductCode','name':'bizProductName'},
					'children' : [{
						'code':'-',
						'name':'工作流规则集',
						'type': Array,
						'depth':4,
						'leaf':false,
						'fields':[],
						'showKey':{'key':'flowCode','name':'flowName'},
						'align':true,
						formatLabel: function(item) {
							return "["+item.businessSideCode+"] " + item.flowName
						},
						uniqCodeFun: function(item) {
							return item['businessSideCode'] + "_" + item['flowCode']
						},
						'children' : [{
							'code':'-',
							'name':'工作流规则集',
							'type': Object,
							'depth':5,
							'leaf':false,
							'fields':['flowRuleAggr'],
							'children' : [{
								'code':'-',
								'name':'工作流规则集列表',
								'type': Array,
								'depth':6,
								'leaf':false,
								'fields':[],
								'showKey':{'key':'ruleId','name':'configGroup'},
								formatLabel: null,
								uniqCodeFun: function(item) {
									return item['configGroup']
								},
								'children' : [{
									'code':'-',
									'name':'工作流规则集列表',
									'type': Array,
									'depth':7,
									'lea你f':true,
									'fields':[],
									'children':[]
								}]
							}]
						}]
					}]
				}]
			}]
		}
		var app = new Vue({
			el: '#app',
			data: {
				origin_data: origin_data,
				selected_tag : '',
				path_data	: [],
				index_data : [],
				index_depth: 0,
				mp_index	 : [],
				left_ctrl_data:[],
				right_ctrl_data:[],
				cursor	 : {depth:0, selected:null}
			},
			created: function() {
				this.selectedTag('MPI')
			},
			methods:{
				moveLeft: function(item) {
					console.log("item", item)
					var right_obj = findCurData('r', this.cursor, this.mp_index, item, prod_mp_data)

					var cur_data = null
					for(var i in right_obj) {
						var obj = right_obj[i]
						if (obj.flowCode == item.code) {
							cur_data = obj
						}
					}

					var left_obj = findCurData('l', this.cursor, this.mp_index, item, sc_mp_data)
					left_obj.push(cur_data)

					var zz = mpi_topology
					var topology = []
					var x = 1

					do {
						if (x == this.cursor.depth) {
							topology = zz.fields
							break
						}

						zz = zz.children[0]
						x++
						
						if (x == this.cursor.depth) {
							topology = zz.fields
							break
						}
					} while (x != this.cursor.depth)

					this.left_ctrl_data.forEach(x => {
						if (x.uniqCode == item.uniqCode) {
							x.opt = 0
						}
					})

					console.log("sc_mp_data", sc_mp_data)
				},
				selectedTag: function(e) {
					this.selected_tag = e
					this.left_ctrl_data.length = 0
					this.mp_index.length = 0

					if (e == 'MPI') {
						for(var i in mp_test_data) {
							this.left_ctrl_data.push({
								code  : mp_test_data[i].manageProductImplCode,
								name  : mp_test_data[i].manageProductImplCode,
								index : -1
							})
							this.right_ctrl_data.push({
								code  : mp_test_data[i].manageProductImplCode,
								name  : mp_test_data[i].manageProductImplCode,
								index : -1
							})
						}

						this.mp_index.push({
							depth   : 1,
							code    : '',
							name    : '',
							index   : -1,
							l_value : true,
							r_value : true,
							type    : 'object' // object,array,number,string
						})
						this.cursor = {depth:0, type:'MPI', l_value: {
								code : mp_test_data[i].manageProductImplCode,
								name : mp_test_data[i].manageProductImplCode,
								index : -1
							}, r_value:{
								code : mp_test_data[i].manageProductImplCode,
								name : mp_test_data[i].manageProductImplCode,
								index : -1
							}}
					}
				},
				selectPath: function(node) {
					// 点击path中最后一个节点，不做变更
					if (node.depth == this.cursor.depth) {
						return
					}

					this.cursor.depth = node.depth - 1
					this.cursor.code  = node.code
					this.cursor.name  = node.name

					this.mp_index = this.mp_index.slice(0, node.depth)
					this.left_ctrl_data = this.left_ctrl_data.slice(0, node.depth)

					this.selectData(node)
				},
				selectData: function(item) {
					// 叶子节点后不再响应点击事件
					if (item.leaf) {
						return
					}

					pre_data = this.mp_index[this.cursor.depth]
					pre_data.selectd = item

					this.mp_index[this.cursor.depth].child = item
					this.cursor.depth++
					this.cursor.selected = item

					var cur_mp_index = {
						depth : this.cursor.depth,
						code  : item.code,
						name  : item.name,
						index : item.index,
						value : null,
						l_value: this.cursor.l_value[item.code] ? true : false,
						r_value: this.cursor.r_value[item.code] ? true : false,
					}
					this.mp_index.push(cur_mp_index)

					left_obj  = findCurData('l', this.cursor, this.mp_index, item, sc_mp_data)
					right_obj = findCurData('r', this.cursor, this.mp_index, item, prod_mp_data)

					cur_mp_index.l_value = !!left_obj
					cur_mp_index.r_value = !!right_obj
					
					this.left_ctrl_data.length  = 0
					this.right_ctrl_data.length = 0

					var zz = mpi_topology
					var topology = []
					var x = 1

					do {
						if (x == this.cursor.depth) {
							topology = zz.fields
							break
						}

						zz = zz.children[0]
						x++
						
						if (x == this.cursor.depth) {
							topology = zz.fields
							break
						}
					} while (x != this.cursor.depth)

					console.log("zz", zz)
					// 已经是叶子节点
					if (zz.leaf) {
						var ret = formatLeafValue(zz.type, left_obj, right_obj)
						console.log("ret", ret)
						this.left_ctrl_data.push({
							name : ret[0],
							leaf : true
						})
						this.right_ctrl_data.push({
							name : ret[1],
							leaf : true
						})
						return
					}

					var left_ctrl_data = setCtrlData(left_obj, topology, zz)
					var right_ctrl_data = setCtrlData(right_obj, topology, zz)

					if (this.cursor.depth == 4 || this.cursor.depth == 6) {
						var text1 = ""
						var text2 = ""
						left_ctrl_data.forEach(x => text1 += x.uniqCode + "\n")
						right_ctrl_data.forEach(x => text2 += x.uniqCode + "\n")

						var diff = diff_lineMode(text1, text2)

						var new_left_ctrl_data = []
						diff.forEach(x => {
							var ctrl_data = x[0] === 1 ? right_ctrl_data : left_ctrl_data
							findNewCtrlData(x[0], x[1], ctrl_data).forEach(m => {
								new_left_ctrl_data.push(m)
							})
						})

						left_ctrl_data  = new_left_ctrl_data
						right_ctrl_data = new_left_ctrl_data
					}
					this.left_ctrl_data  = left_ctrl_data
					this.right_ctrl_data = right_ctrl_data

					this.cursor.l_value = left_ctrl_data
					this.cursor.r_value = right_ctrl_data
				}
			}
		})

		var formatLeafValue = function(type, left_obj, right_obj) {
			var retValue = []

			var data = [left_obj, right_obj]
			data.forEach(x => {
				var context = ""
				if (type == Object) {
					context = JSON.stringify(left_obj)
				} else if (type == String || type == Number) {
					context = left_obj
				}
				retValue.push(context)
			})
			
			return retValue
		}

		var splitLine = function(text) {
			var _codes = []
			text.split('\n').forEach(x => {
				if (x.length > 0) {
					_codes.push(x)
				}
			})
			return _codes
		}

		var findNewCtrlData = function(opt, text, ctrl_data) {
			var _data = []
			splitLine(text).forEach(uniqCode => {
				ctrl_data.forEach(x => {
					if (x.uniqCode == uniqCode) {
						x.opt = opt
						_data.push(x)
					}
				})
			})
			return _data
		}

		var sortFun = function(a, b) {
			var nameA = a.uniqCode.toUpperCase()
			var nameB = b.uniqCode.toUpperCase()
			if (nameA < nameB) {
				return -1
			}
			if (nameA > nameB) {
				return 1
			}

			return 0
		}

		var setCtrlData = function(input_data, topology, meta) {
			var ret_data = []
			if (input_data == null) {
				return []
			}

			if (input_data !== undefined) {
				if (Array.isArray(input_data)) {
					for(var i in input_data) {
						var _item = input_data[i]
						if (meta.showKey !== undefined) {
							var x_code = meta.showKey.key
							var x_name = meta.showKey.name

							ret_data.push({
								uniqCode : meta.uniqCodeFun ? meta.uniqCodeFun(_item) : _item[x_code],
								code     : _item[x_code],
								name     : meta.formatLabel ? meta.formatLabel(_item) : _item[x_name],
								index    : i,
							})
						}
					}
				} else {
					var keys = Object.keys(input_data)
					for (var i = 0; i < keys.length; i++) {
						var code = keys[i]
						if (topology.indexOf(code) != -1) {
							ret_data.push({
								code : code,
								name : findTopologyName(code),
								index : i
							})
						}
					}
				}
			}
			// 数据排序
			if (meta.align) {
				ret_data.sort(sortFun)
			}
			return ret_data
		}

		var findTopologyName = function(code) {
			if (mp_key_frame[code]) {
				return mp_key_frame[code]
			}
			return code
		}

		var findTopologyCursor = function(cursor) {
			// var tt;
			// var d = 0;
			// while(d <= cursor.depth) {
			// 	if ()
			// 	tt = mpi_topology.children
			// }
			return code
		}

		var findCurData = function(from, cursor, mp_index, item, mp_data) {
			if (cursor.type == 'MPI') {
				if (cursor.depth == 1) {
					return mp_data
				} else {
					var i = 2
					var cur = mp_index[i]
					var obj = mp_data[cur.code]

					while(cur.depth != cursor.depth) {
						i++
						cur = mp_index[i]
						
						if (Array.isArray(obj)) {
							obj = obj[parseInt(cur.index)]
						} else {
							obj = obj[cur.code]
						}

						if ('l' == from && !cur.l_value) {
							break
						}
						if ('r' == from && !cur.r_value) {
							break
						}
					}
					if (cursor.depth == 5 && obj.flowCode !== item.code) {
						return null
					}
					return obj
				}
			}
		}
	</script>
</body>
</html>