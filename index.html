<!DOCTYPE html>
<html>
<head>
	<title>test</title>
	<meta charset="UTF-8">
	<script src="./vue.js"></script>
	<script src="./diff_match_patch.js"></script>
	<style type="text/css">
		.bbox {
			border:1px solid #ccc;
			width:45%;
			height:400px;
			overflow: auto;
			display: inline-table;
			padding: 5px;
			float: left;
		}
		.opt_lable {
			font-size: 0.9em;
			display: inline-table;
			margin:2px;
			width: 1.2em;
			text-align: center;
		}
		.txt_line {
			margin:2px 3px;
			padding: 2px 3px;
			cursor:pointer;
			display: inline-table;
			height: 24px;
		}
		.opt_add_bg {
			color: #CCCCCC;
			border: 1px dashed #CCCC99;
			background-color: #CCFFFF;
			height: 22px;
		}
		.opt_rm_bg {
			color: #333333;
			background-color: #FF9999;
			border: 1px solid #FF6666;
			height: 22px;
		}
		.opt_rm_r_bg {
			color: #999999;
			border: 1px dashed #FF6666;
			background-color: #FF9999;
			height: 22px;
		}
		.opt_button {
			color: #EEEEEE;
			background-color: #3366CC;
			width: 17px;
			height: 18px;
			padding: 1px 2px;
			font-size: 0.6em;
			border-radius: 4px/4px;
			cursor: pointer;
		}
	</style>
</head>
<body>
<div id="app">
	<div>
		<h4>MPI比对工具</h4>
	</div>
	<div>
		<b>Path:</b>
		<span v-for="node in mp_index" v-on:click="selectPath(node)" style="cursor: pointer;">
			<span>/</span>
			{{node.name}}
		</span>
	</div>
	<div class="bbox">
		<div v-for="item in left_ctrl_data">
			<em class="opt_lable" v-if="item.opt == 1">+</em>
			<em class="opt_lable" v-if="item.opt == -1">*</em>
			<em class="opt_lable" v-if="item.opt == 0"> </em>
			<div v-on:click="selectData(item)"
				v-bind:class="{opt_add_bg:item.opt==1, opt_rm_bg:item.opt==-1}"
				class="txt_line">{{item.name}}</div>
		</div>
	</div>
	<div class="bbox">
		<div v-for="item in right_ctrl_data">
			<em class="opt_lable opt_button" v-if="item.opt==1" v-on:click="moveLeft(item)">&lt;&lt;</em>
			<em class="opt_lable" v-else> </em>
			<div v-on:click="selectData(item)"
				v-bind:class="{opt_rm_r_bg:item.opt==-1}"
				class="txt_line">
				{{item.name}}
			</div>
		</div>
	</div>
	<div>

	</div>
</div>
	<script type="text/javascript">
		var prod_mp_data
		var sc_mp_data
		fetch('./prod_mp_data.json')
		.then(response => response.json())
		.then(data => {
			prod_mp_data = data.data
			console.log("prod_mp_data", prod_mp_data)
		})
		fetch('./sc_mp_data.json')
		.then(response => response.json())
		.then(data => {
			sc_mp_data = data.data
			console.log("sc_mp_data", sc_mp_data)
		})

		function diff_lineMode(text1, text2) {
			var dmp = new diff_match_patch()
			var a = dmp.diff_linesToChars_(text1, text2)
			var lineText1 = a.chars1
			var lineText2 = a.chars2
			var lineArray = a.lineArray
			var diffs = dmp.diff_main(lineText1, lineText2, false)
			dmp.diff_charsToLines_(diffs, lineArray)
		
			return diffs;
		}

		var mp_test_data = [{'manageProductImplCode':'MPI20210625120222062564'}]

		var mp_key_frame = {'MPI':"MP", "bizProducts":"产品类型列表", "bizProductFlows":"工作流列表","flowRuleAggr":"工作流规则集"}
		var mpi_topology = {
			'code':'MPI',
			'name':'MP实例',
			'type': 'object',
			'depth':0,
			'leaf':false,
			'fields':['bizProducts'],
			'children': [{
				'code':'bizProducts',
				'name':'产品类型列表',
				'type': 'array',
				'depth':1,
				'leaf':false,
				'fields':[],
				'showKey':{'key':'bizProductCode','name':'bizProductName'},
				sortCompare: function(a, b) {
					var aKey = a.bizProductCode.toUpperCase()
					var bKey = b.bizProductCode.toUpperCase()
					if (aKey < bKey) {
						return -1
					}
					if (aKey > bKey) {
						return 1
					}

					return 0
				},
				'children' : [{
					'code':'bizProductFlows',
					'name':'工作流列表',
					'type': 'object',
					'depth':2,
					'leaf':false,
					'fields':['bizProductFlows'],
					// 'showKey':{'key':'bizProductCode','name':'bizProductName'},
					compare: function(left_data, right_data) {
						if (left_data == undefined || right_data == undefined) {
							return false
						}
						if (left_data.length !== right_data.length) {
							return false
						}

						var diff = true
						for (var i in left_data) {
							var a = left_data[i]
							var b
							for (var j in right_data) {
								var x = right_data[j]
								if (a.bizProductCode == x.bizProductCode) {
									b = x
								}
							}

							if (b == undefined) {
								diff = false
							}
							if (a.bizProductName !== b.bizProductName) {
								diff = false
							}

							if (!diff) {
								break
							}
						}
						return diff
					},
					'children' : [{
						'code':'-',
						'name':'工作流规则集',
						'type': 'array',
						'depth':3,
						'leaf':false,
						'fields':[],
						'showKey':{'key':'flowCode','name':'flowName'},
						'align':true,
						formatLabel: function(item) {
							return "["+item.businessSideCode+"] " + item.flowName
						},
						uniqCodeFun: function(item) {
							return item['businessSideCode'] + "_" + item['flowCode']
						},
						diffFun: function(a, b) {
							if (a.businessSideCode !== b.businessSideCode) {
								return false
							}
							if (a.bizProductName !== b.bizProductName) {
								return false
							}
							return true
						},
						'children' : [{
							'code':'-',
							'name':'工作流规则集',
							'type': 'object',
							'depth':4,
							'leaf':false,
							'fields':['flowRuleAggr'],
							'children' : [{
								'code':'-',
								'name':'工作流规则集列表',
								'type': 'array',
								'depth':5,
								'leaf':false,
								'fields':[],
								'showKey':{'key':'ruleId','name':'configGroup'},
								formatLabel: null,
								uniqCodeFun: function(item) {
									return item['configGroup']
								},
								'children' : [{
									'code'     : '-',
									'name'     : '工作流规则集列表',
									'type'     : 'array',
									'depth'    : 6,
									'leaf'     : true,
									'fields'   : [],
									'children' : []
								}]
							}]
						}]
					}]
				}]
			}]
		}


		var deepDiff = function(cursor, mp_meta, left_data, right_data) {
			var path  = cursor.t_path

			var meta  = findMetaData(cursor.t_path, mp_meta)

			var diffs = []
			if (meta.compare) {
				var diff = meta.compare(left_data, right_data)
			} else {
				for (var k in left_data) {
					var l_o = left_data[k]
					var r_o = right_data[k]
					if (r_o == undefined) {
						diffs.push({'path': pathAdd(path, k), 'opt':1})
					}
					if (typeof(l_o) == 'string' || typeof(l_o) == 'number') {
						if (l_o === r_o) {
							diffs.push({'path': pathAdd(path, k), 'opt':0})
						} else {
							diffs.push({'path': pathAdd(path, k), 'opt':2})
						}
					}

					if (typeof(l_o) == 'object') {
						if (Array.isArray(l_o)) {
							l_o.sort(meta.sortCompare)
							r_o.sort(meta.sortCompare)
						}

						var cc = {
							t_path : pathAdd(path, k),
							l_path : pathAdd(path, k),
							r_path : pathAdd(path, k),
							depth : cursor.depth + 1
						}
						var _diffs = deepObjectDiff(cc, mp_meta, l_o, r_o)
						_diffs.forEach(d => {
							diffs.push(d)
						})
					}
				}
			}
			return diffs
		}

		var deepObjectDiff = function(paths, mp_meta, left_data, right_data) {
			if (paths.depth >= 5) {
				return []
			}


			var diffs = []
			var path = paths.t_path

			if (path == '/ruleAggrDetail') {
				return []
			}

			for (var k in left_data) {
				var l_o = left_data[k]
				
				if (right_data[k] == undefined) {
					diffs.push({'path': pathAdd(path, k), 'opt':1})
					continue
				}
				var r_o = right_data[k]
				
				if (typeof(l_o) == 'string' || typeof(l_o) == 'number') {
					if (l_o === r_o) {
						diffs.push({'path': pathAdd(path, k), 'opt':0})
					} else {
						diffs.push({'path': pathAdd(path, k), 'opt':2})
					}
				}

				if (typeof(l_o) == 'object') {
					var cc = {
						t_path : paths.t_path = pathAdd(path, k),
						l_path : paths.l_path = pathAdd(path, k),
						r_path : paths.r_path = pathAdd(path, k),
						depth  : paths.depth + 1
					}
					var _diffs = deepObjectDiff(cc, mp_meta, l_o, r_o)
					_diffs.forEach(d => {
						diffs.push(d)
					})
				}
			}
			return diffs
		}

		var pathAdd = function(old_path, child_path) {
			return old_path == '/' ? old_path + child_path : old_path +'/'+child_path
		}



		var formatLeafValue = function(type, left_obj, right_obj) {
			var retValue = []

			var data = [left_obj, right_obj]
			data.forEach(x => {
				var context = ""
				if (type == Object) {
					context = JSON.stringify(left_obj)
				} else if (type == String || type == Number) {
					context = left_obj
				}
				retValue.push(context)
			})
			
			return retValue
		}

		var splitLine = function(text) {
			var _codes = []
			text.split('\n').forEach(x => {
				if (x.length > 0) {
					_codes.push(x)
				}
			})
			return _codes
		}

		var findNewCtrlData = function(opt, text, ctrl_data) {
			var _data = []
			splitLine(text).forEach(uniqCode => {
				ctrl_data.forEach(x => {
					if (x.uniqCode == uniqCode) {
						x.opt = opt
						_data.push(x)
					}
				})
			})
			return _data
		}

		var sortFun = function(a, b) {
			var nameA = a.uniqCode.toUpperCase()
			var nameB = b.uniqCode.toUpperCase()
			if (nameA < nameB) {
				return -1
			}
			if (nameA > nameB) {
				return 1
			}

			return 0
		}

		var setCtrlData = function(input_data, topology, meta, item) {
			var ret_data = []
			if (input_data == null) {
				return []
			}

			console.log("meta", meta)
			console.log("input_data", input_data)

			if (input_data !== undefined) {
				if (Array.isArray(input_data)) {
					for(var i in input_data) {
						var _item = input_data[i]
						if (meta.showKey !== undefined) {
							var x_code = meta.showKey.key
							var x_name = meta.showKey.name

							ret_data.push({
								uniqCode : meta.uniqCodeFun ? meta.uniqCodeFun(_item) : _item[x_code],
								code     : _item[x_code],
								name     : meta.formatLabel ? meta.formatLabel(_item) : _item[x_name],
								index    : meta.type == 'array' ? i : x_code,
								depth    : item.depth + 1,
							})
						}
					}
				} else {
					var keys = Object.keys(input_data)
					for (var i = 0; i < keys.length; i++) {
						var code = keys[i]
						if (topology.indexOf(code) != -1) {
							ret_data.push({
								code  : code,
								name  : findTopologyName(code),
								index : code,
								depth : item.depth + 1,
							})
						}
					}
				}
			}
			// 数据排序
			if (meta.align) {
				ret_data.sort(sortFun)
			}
			return ret_data
		}

		var findTopologyName = function(code) {
			if (mp_key_frame[code]) {
				return mp_key_frame[code]
			}
			return code
		}

		var findMetaData = function(path, srcMeta) {
			console.log("path", path)
			if (path == '/') {
				return srcMeta
			}

			var paths = path.split('/')
			console.log("paths", paths)
			var meta = srcMeta//.children[0]
			var _path = ''
			while (paths.length > 0) {
				_path = paths.shift()
				if (_path == '') {
					continue
				}
				meta = meta.children[0]
				// paths.shift()
			}
			return meta

		}

		var findData = function(path, mp_data) {
			if (path == '/') {
				return mp_data
			}

			var paths = path.split('/')
			paths.shift()
			paths.shift() // 空路径，扔掉，待优化

			var path = paths.shift()
			var obj  = mp_data[path]

			while (paths.length > 0) {
				path = paths.shift()
				obj  = obj[path]
			}

			return obj
		}

		var findCurData = function(from, cursor, mp_index, item, mp_data) {
			if (cursor.depth == 0) {
				return mp_data
			} else {
				var paths
				if (from == 'l') {
					paths = cursor.l_path.split('/')
				}
				if (from == 'r') {
					paths = cursor.r_path.split('/')
				}

				var path = ''//paths.shift()
				
				var obj
				while (paths.length > 0) {
					path = paths.shift()
					if (path == '') {
						obj = mp_data
						continue
					}
					obj  = obj[path]
				}

				return obj
			}
		}

		var app = new Vue({
			el: '#app',
			data: {
				mp_index	    : [],
				left_ctrl_data  : [],
				right_ctrl_data : [],
				cursor	        : {depth:0, selected:null}
			},
			created: function() {
				this.selectedTag('MPI')
			},
			methods:{
				moveLeft: function(item) {
					var right_obj = findCurData('r', this.cursor, this.mp_index, item, prod_mp_data)

					var cur_data = null
					for(var i in right_obj) {
						var obj = right_obj[i]
						if (obj.flowCode == item.code) {
							cur_data = obj
						}
					}

					var left_obj = findCurData('l', this.cursor, this.mp_index, item, sc_mp_data)
					left_obj.push(cur_data)

					var zz = mpi_topology
					var topology = []
					var x = 1

					do {
						if (x == this.cursor.depth) {
							topology = zz.fields
							break
						}

						zz = zz.children[0]
						x++
						
						if (x == this.cursor.depth) {
							topology = zz.fields
							break
						}
					} while (x != this.cursor.depth)

					this.left_ctrl_data.forEach(x => {
						if (x.uniqCode == item.uniqCode) {
							x.opt = 0
						}
					})
				},
				selectedTag: function(e) {
					this.left_ctrl_data.length = 0
					this.mp_index.length       = 0

					// 测试数据，需要根据实际业务指定
					var default_data = {
						code  : mp_test_data[0].manageProductImplCode,
						name  : mp_test_data[0].manageProductImplCode,
						index : '/',
						depth : 0,
					}

					for(var i in mp_test_data) {
						this.left_ctrl_data.push(default_data)
						this.right_ctrl_data.push(default_data)
					}

					this.mp_index.push({
						depth   : 0,
						code    : '',
						name    : '',
						index   : '/',
						l_value : true,
						r_value : true,
						type    : 'object' // object,array,number,string
					})
					this.cursor = {
						depth   : 0,
						type    : 'MPI',
						l_value : default_data,
						r_value : default_data,
						l_path  : "/",
						r_path  : "/",
						t_path  : "/",
					}
					var cursor = this.cursor

					// setTimeout(function() {deepDiff(cursor, mpi_topology, sc_mp_data, prod_mp_data)}, 1000)
				},
				selectPath: function(node) {
					// 点击path中最后一个节点，不做变更
					if (node.depth == this.cursor.depth) {
						return
					}

					this.cursor.depth = node.depth
					this.cursor.code  = node.code
					this.cursor.name  = node.name

					this.mp_index = this.mp_index.slice(0, node.depth)
					this.left_ctrl_data = this.left_ctrl_data.slice(0, node.depth)

					this.selectData(node)
				},
				selectData: function(item) {
					// 叶子节点后不再响应点击事件
					if (item.leaf) {
						return
					}

					if (item.depth == 0) {
						this.mp_index.length = 0
						this.cursor.depth    = 0
						this.cursor.l_path   = '/'
						this.cursor.r_path   = '/'
						this.cursor.t_path   = '/'
					}

					var cur_mp_index = {
						depth   : item.depth,
						code    : item.code,
						name    : item.name,
						index   : item.index,
						l_value : this.cursor.l_value[item.code] ? true : false,
						r_value : this.cursor.r_value[item.code] ? true : false,
					}
					this.mp_index.push(cur_mp_index)

					console.log("item", item)
					console.log("this.cursorxxx", this.cursor)

					this.cursor.depth = item.depth

					if (item.depth >= 1) {
						var paths = this.cursor.l_path
						paths = paths.split('/').slice(1, item.depth)
						paths.push(item.index)
						this.cursor.l_path = '/'+ paths.join('/')

						paths = this.cursor.r_path
						paths = paths.split('/').slice(1, item.depth)
						paths.push(item.index)
						this.cursor.r_path = '/'+ paths.join('/')

						paths = this.cursor.t_path
						paths = paths.split('/').slice(1, item.depth)
						paths.push(item.index)
						this.cursor.t_path = '/'+ paths.join('/')
					}

					console.log("this.cursor", this.cursor)

					left_obj  = findCurData('l', this.cursor, this.mp_index, item, sc_mp_data)
					right_obj = findCurData('r', this.cursor, this.mp_index, item, prod_mp_data)

					cur_mp_index.l_value = !!left_obj
					cur_mp_index.r_value = !!right_obj
					console.log("left_obj", left_obj)
					console.log("right_obj", right_obj)
					
					this.left_ctrl_data.length  = 0
					this.right_ctrl_data.length = 0

					// this.cursor.depth++

					var zz = findMetaData(this.cursor.t_path, mpi_topology)
					var topology = zz.fields
					console.log("zz", zz)

					// 已经是叶子节点
					if (zz.leaf) {
						var ret = formatLeafValue(zz.type, left_obj, right_obj)
						this.left_ctrl_data.push({
							name : ret[0],
							leaf : true
						})
						this.right_ctrl_data.push({
							name : ret[1],
							leaf : true
						})
						return
					}

					var left_ctrl_data  = setCtrlData(left_obj, topology, zz, item)
					var right_ctrl_data = setCtrlData(right_obj, topology, zz, item)

					if (zz.depth == 3 || zz.depth == 5) {
						var text1 = ""
						var text2 = ""
						left_ctrl_data.forEach(x => text1 += x.uniqCode + "\n")
						right_ctrl_data.forEach(x => text2 += x.uniqCode + "\n")

						var diff = diff_lineMode(text1, text2)

						var new_left_ctrl_data = []
						diff.forEach(x => {
							var ctrl_data = x[0] === 1 ? right_ctrl_data : left_ctrl_data
							findNewCtrlData(x[0], x[1], ctrl_data).forEach(m => {
								new_left_ctrl_data.push(m)
							})
						})

						left_ctrl_data  = new_left_ctrl_data
						right_ctrl_data = new_left_ctrl_data
					}
					this.left_ctrl_data  = left_ctrl_data
					this.right_ctrl_data = right_ctrl_data

					this.cursor.l_value = left_ctrl_data
					this.cursor.r_value = right_ctrl_data

					if (item.depth > 0) {
						var diff = deepDiff(this.cursor, mpi_topology, left_obj, right_obj)
						console.log("diff", diff)
					}
				}
			}
		})

	</script>
</body>
</html>